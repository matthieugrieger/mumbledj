// Code generated by protoc-gen-go.
// source: Mumble.proto
// DO NOT EDIT!

/*
Package MumbleProto is a generated protocol buffer package.

It is generated from these files:
	Mumble.proto

It has these top-level messages:
	Version
	UDPTunnel
	Authenticate
	Ping
	Reject
	ServerSync
	ChannelRemove
	ChannelState
	UserRemove
	UserState
	BanList
	TextMessage
	PermissionDenied
	ACL
	QueryUsers
	CryptSetup
	ContextActionModify
	ContextAction
	UserList
	VoiceTarget
	PermissionQuery
	CodecVersion
	UserStats
	RequestBlob
	ServerConfig
	SuggestConfig
*/
package MumbleProto

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Reject_RejectType int32

const (
	// TODO ??
	Reject_None Reject_RejectType = 0
	// The client attempted to connect with an incompatible version.
	Reject_WrongVersion Reject_RejectType = 1
	// The user name supplied by the client was invalid.
	Reject_InvalidUsername Reject_RejectType = 2
	// The client attempted to authenticate as a user with a password but it
	// was wrong.
	Reject_WrongUserPW Reject_RejectType = 3
	// The client attempted to connect to a passworded server but the password
	// was wrong.
	Reject_WrongServerPW Reject_RejectType = 4
	// Supplied username is already in use.
	Reject_UsernameInUse Reject_RejectType = 5
	// Server is currently full and cannot accept more users.
	Reject_ServerFull Reject_RejectType = 6
	// The user did not provide a certificate but one is required.
	Reject_NoCertificate     Reject_RejectType = 7
	Reject_AuthenticatorFail Reject_RejectType = 8
)

var Reject_RejectType_name = map[int32]string{
	0: "None",
	1: "WrongVersion",
	2: "InvalidUsername",
	3: "WrongUserPW",
	4: "WrongServerPW",
	5: "UsernameInUse",
	6: "ServerFull",
	7: "NoCertificate",
	8: "AuthenticatorFail",
}
var Reject_RejectType_value = map[string]int32{
	"None":              0,
	"WrongVersion":      1,
	"InvalidUsername":   2,
	"WrongUserPW":       3,
	"WrongServerPW":     4,
	"UsernameInUse":     5,
	"ServerFull":        6,
	"NoCertificate":     7,
	"AuthenticatorFail": 8,
}

func (x Reject_RejectType) Enum() *Reject_RejectType {
	p := new(Reject_RejectType)
	*p = x
	return p
}
func (x Reject_RejectType) String() string {
	return proto.EnumName(Reject_RejectType_name, int32(x))
}
func (x *Reject_RejectType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Reject_RejectType_value, data, "Reject_RejectType")
	if err != nil {
		return err
	}
	*x = Reject_RejectType(value)
	return nil
}

type PermissionDenied_DenyType int32

const (
	// Operation denied for other reason, see reason field.
	PermissionDenied_Text PermissionDenied_DenyType = 0
	// Permissions were denied.
	PermissionDenied_Permission PermissionDenied_DenyType = 1
	// Cannot modify SuperUser.
	PermissionDenied_SuperUser PermissionDenied_DenyType = 2
	// Invalid channel name.
	PermissionDenied_ChannelName PermissionDenied_DenyType = 3
	// Text message too long.
	PermissionDenied_TextTooLong PermissionDenied_DenyType = 4
	// The flux capacitor was spelled wrong.
	PermissionDenied_H9K PermissionDenied_DenyType = 5
	// Operation not permitted in temporary channel.
	PermissionDenied_TemporaryChannel PermissionDenied_DenyType = 6
	// Operation requires certificate.
	PermissionDenied_MissingCertificate PermissionDenied_DenyType = 7
	// Invalid username.
	PermissionDenied_UserName PermissionDenied_DenyType = 8
	// Channel is full.
	PermissionDenied_ChannelFull  PermissionDenied_DenyType = 9
	PermissionDenied_NestingLimit PermissionDenied_DenyType = 10
)

var PermissionDenied_DenyType_name = map[int32]string{
	0:  "Text",
	1:  "Permission",
	2:  "SuperUser",
	3:  "ChannelName",
	4:  "TextTooLong",
	5:  "H9K",
	6:  "TemporaryChannel",
	7:  "MissingCertificate",
	8:  "UserName",
	9:  "ChannelFull",
	10: "NestingLimit",
}
var PermissionDenied_DenyType_value = map[string]int32{
	"Text":               0,
	"Permission":         1,
	"SuperUser":          2,
	"ChannelName":        3,
	"TextTooLong":        4,
	"H9K":                5,
	"TemporaryChannel":   6,
	"MissingCertificate": 7,
	"UserName":           8,
	"ChannelFull":        9,
	"NestingLimit":       10,
}

func (x PermissionDenied_DenyType) Enum() *PermissionDenied_DenyType {
	p := new(PermissionDenied_DenyType)
	*p = x
	return p
}
func (x PermissionDenied_DenyType) String() string {
	return proto.EnumName(PermissionDenied_DenyType_name, int32(x))
}
func (x *PermissionDenied_DenyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PermissionDenied_DenyType_value, data, "PermissionDenied_DenyType")
	if err != nil {
		return err
	}
	*x = PermissionDenied_DenyType(value)
	return nil
}

type ContextActionModify_Context int32

const (
	// Action is applicable to the server.
	ContextActionModify_Server ContextActionModify_Context = 1
	// Action can target a Channel.
	ContextActionModify_Channel ContextActionModify_Context = 2
	// Action can target a User.
	ContextActionModify_User ContextActionModify_Context = 4
)

var ContextActionModify_Context_name = map[int32]string{
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextActionModify_Context_value = map[string]int32{
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextActionModify_Context) Enum() *ContextActionModify_Context {
	p := new(ContextActionModify_Context)
	*p = x
	return p
}
func (x ContextActionModify_Context) String() string {
	return proto.EnumName(ContextActionModify_Context_name, int32(x))
}
func (x *ContextActionModify_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextActionModify_Context_value, data, "ContextActionModify_Context")
	if err != nil {
		return err
	}
	*x = ContextActionModify_Context(value)
	return nil
}

type ContextActionModify_Operation int32

const (
	ContextActionModify_Add    ContextActionModify_Operation = 0
	ContextActionModify_Remove ContextActionModify_Operation = 1
)

var ContextActionModify_Operation_name = map[int32]string{
	0: "Add",
	1: "Remove",
}
var ContextActionModify_Operation_value = map[string]int32{
	"Add":    0,
	"Remove": 1,
}

func (x ContextActionModify_Operation) Enum() *ContextActionModify_Operation {
	p := new(ContextActionModify_Operation)
	*p = x
	return p
}
func (x ContextActionModify_Operation) String() string {
	return proto.EnumName(ContextActionModify_Operation_name, int32(x))
}
func (x *ContextActionModify_Operation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextActionModify_Operation_value, data, "ContextActionModify_Operation")
	if err != nil {
		return err
	}
	*x = ContextActionModify_Operation(value)
	return nil
}

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

// Not used. Not even for tunneling UDP through TCP.
type UDPTunnel struct {
	// Not used.
	Packet           []byte `protobuf:"bytes,1,req,name=packet" json:"packet,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UDPTunnel) Reset()         { *m = UDPTunnel{} }
func (m *UDPTunnel) String() string { return proto.CompactTextString(m) }
func (*UDPTunnel) ProtoMessage()    {}

func (m *UDPTunnel) GetPacket() []byte {
	if m != nil {
		return m.Packet
	}
	return nil
}

// Used by the client to send the authentication credentials to the server.
type Authenticate struct {
	// UTF-8 encoded username.
	Username *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Server or user password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// Additional access tokens for server ACL groups.
	Tokens []string `protobuf:"bytes,3,rep,name=tokens" json:"tokens,omitempty"`
	// A list of CELT bitstream version constants supported by the client.
	CeltVersions     []int32 `protobuf:"varint,4,rep,name=celt_versions" json:"celt_versions,omitempty"`
	Opus             *bool   `protobuf:"varint,5,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticate) Reset()         { *m = Authenticate{} }
func (m *Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticate) ProtoMessage()    {}

const Default_Authenticate_Opus bool = false

func (m *Authenticate) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *Authenticate) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Authenticate) GetTokens() []string {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *Authenticate) GetCeltVersions() []int32 {
	if m != nil {
		return m.CeltVersions
	}
	return nil
}

func (m *Authenticate) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_Authenticate_Opus
}

// Sent by the client to notify the server that the client is still alive.
// Server must reply to the packet with the same timestamp and its own
// good/late/lost/resync numbers. None of the fields is strictly required.
type Ping struct {
	// Client timestamp. Server should not attempt to decode.
	Timestamp *uint64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,2,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,3,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,4,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync *uint32 `protobuf:"varint,5,opt,name=resync" json:"resync,omitempty"`
	// The total amount of UDP packets received.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets" json:"udp_packets,omitempty"`
	// The total amount of TCP packets received.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar       *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var" json:"tcp_ping_var,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Ping) Reset()         { *m = Ping{} }
func (m *Ping) String() string { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()    {}

func (m *Ping) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Ping) GetGood() uint32 {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return 0
}

func (m *Ping) GetLate() uint32 {
	if m != nil && m.Late != nil {
		return *m.Late
	}
	return 0
}

func (m *Ping) GetLost() uint32 {
	if m != nil && m.Lost != nil {
		return *m.Lost
	}
	return 0
}

func (m *Ping) GetResync() uint32 {
	if m != nil && m.Resync != nil {
		return *m.Resync
	}
	return 0
}

func (m *Ping) GetUdpPackets() uint32 {
	if m != nil && m.UdpPackets != nil {
		return *m.UdpPackets
	}
	return 0
}

func (m *Ping) GetTcpPackets() uint32 {
	if m != nil && m.TcpPackets != nil {
		return *m.TcpPackets
	}
	return 0
}

func (m *Ping) GetUdpPingAvg() float32 {
	if m != nil && m.UdpPingAvg != nil {
		return *m.UdpPingAvg
	}
	return 0
}

func (m *Ping) GetUdpPingVar() float32 {
	if m != nil && m.UdpPingVar != nil {
		return *m.UdpPingVar
	}
	return 0
}

func (m *Ping) GetTcpPingAvg() float32 {
	if m != nil && m.TcpPingAvg != nil {
		return *m.TcpPingAvg
	}
	return 0
}

func (m *Ping) GetTcpPingVar() float32 {
	if m != nil && m.TcpPingVar != nil {
		return *m.TcpPingVar
	}
	return 0
}

// Sent by the server when it rejects the user connection.
type Reject struct {
	// Rejection type.
	Type *Reject_RejectType `protobuf:"varint,1,opt,name=type,enum=MumbleProto.Reject_RejectType" json:"type,omitempty"`
	// Human readable rejection reason.
	Reason           *string `protobuf:"bytes,2,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Reject) Reset()         { *m = Reject{} }
func (m *Reject) String() string { return proto.CompactTextString(m) }
func (*Reject) ProtoMessage()    {}

func (m *Reject) GetType() Reject_RejectType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Reject_None
}

func (m *Reject) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

// ServerSync message is sent by the server when it has authenticated the user
// and finished synchronizing the server state.
type ServerSync struct {
	// The session of the current user.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// Maximum bandwidth that the user should use.
	MaxBandwidth *uint32 `protobuf:"varint,2,opt,name=max_bandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,3,opt,name=welcome_text" json:"welcome_text,omitempty"`
	// Current user permissions TODO: Confirm??
	Permissions      *uint64 `protobuf:"varint,4,opt,name=permissions" json:"permissions,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ServerSync) Reset()         { *m = ServerSync{} }
func (m *ServerSync) String() string { return proto.CompactTextString(m) }
func (*ServerSync) ProtoMessage()    {}

func (m *ServerSync) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *ServerSync) GetMaxBandwidth() uint32 {
	if m != nil && m.MaxBandwidth != nil {
		return *m.MaxBandwidth
	}
	return 0
}

func (m *ServerSync) GetWelcomeText() string {
	if m != nil && m.WelcomeText != nil {
		return *m.WelcomeText
	}
	return ""
}

func (m *ServerSync) GetPermissions() uint64 {
	if m != nil && m.Permissions != nil {
		return *m.Permissions
	}
	return 0
}

// Sent by the client when it wants a channel removed. Sent by the server when
// a channel has been removed and clients should be notified.
type ChannelRemove struct {
	ChannelId        *uint32 `protobuf:"varint,1,req,name=channel_id" json:"channel_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ChannelRemove) Reset()         { *m = ChannelRemove{} }
func (m *ChannelRemove) String() string { return proto.CompactTextString(m) }
func (*ChannelRemove) ProtoMessage()    {}

func (m *ChannelRemove) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

// Used to communicate channel properties between the client and the server.
// Sent by the server during the login process or when channel properties are
// updated. Client may use this message to update said channel properties.
type ChannelState struct {
	// Unique ID for the channel within the server.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id" json:"channel_id,omitempty"`
	// channel_id of the parent channel.
	Parent *uint32 `protobuf:"varint,2,opt,name=parent" json:"parent,omitempty"`
	// UTF-8 encoded channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// A collection of channel id values of the linked channels. Absent during
	// the first channel listing.
	Links []uint32 `protobuf:"varint,4,rep,name=links" json:"links,omitempty"`
	// UTF-8 encoded channel description. Only if the description is less than
	// 128 bytes
	Description *string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A collection of channel_id values that should be added to links.
	LinksAdd []uint32 `protobuf:"varint,6,rep,name=links_add" json:"links_add,omitempty"`
	// A collection of channel_id values that should be removed from links.
	LinksRemove []uint32 `protobuf:"varint,7,rep,name=links_remove" json:"links_remove,omitempty"`
	// True if the channel is temporary.
	Temporary *bool `protobuf:"varint,8,opt,name=temporary,def=0" json:"temporary,omitempty"`
	// Position weight to tweak the channel position in the channel list.
	Position *int32 `protobuf:"varint,9,opt,name=position,def=0" json:"position,omitempty"`
	// SHA1 hash of the description if the description is 128 bytes or more.
	DescriptionHash  []byte `protobuf:"bytes,10,opt,name=description_hash" json:"description_hash,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ChannelState) Reset()         { *m = ChannelState{} }
func (m *ChannelState) String() string { return proto.CompactTextString(m) }
func (*ChannelState) ProtoMessage()    {}

const Default_ChannelState_Temporary bool = false
const Default_ChannelState_Position int32 = 0

func (m *ChannelState) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ChannelState) GetParent() uint32 {
	if m != nil && m.Parent != nil {
		return *m.Parent
	}
	return 0
}

func (m *ChannelState) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ChannelState) GetLinks() []uint32 {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *ChannelState) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *ChannelState) GetLinksAdd() []uint32 {
	if m != nil {
		return m.LinksAdd
	}
	return nil
}

func (m *ChannelState) GetLinksRemove() []uint32 {
	if m != nil {
		return m.LinksRemove
	}
	return nil
}

func (m *ChannelState) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return Default_ChannelState_Temporary
}

func (m *ChannelState) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return Default_ChannelState_Position
}

func (m *ChannelState) GetDescriptionHash() []byte {
	if m != nil {
		return m.DescriptionHash
	}
	return nil
}

// Used to communicate user leaving or being kicked. May be sent by the client
// when it attempts to kick a user. Sent by the server when it informs the
// clients that a user is not present anymore.
type UserRemove struct {
	// The user who is being kicked, identified by their session, not present
	// when no one is being kicked.
	Session *uint32 `protobuf:"varint,1,req,name=session" json:"session,omitempty"`
	// The user who initiated the removal. Either the user who performs the kick
	// or the user who is currently leaving.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// Reason for the kick, stored as the ban reason if the user is banned.
	Reason *string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	// True if the kick should result in a ban.
	Ban              *bool  `protobuf:"varint,4,opt,name=ban" json:"ban,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UserRemove) Reset()         { *m = UserRemove{} }
func (m *UserRemove) String() string { return proto.CompactTextString(m) }
func (*UserRemove) ProtoMessage()    {}

func (m *UserRemove) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserRemove) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *UserRemove) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *UserRemove) GetBan() bool {
	if m != nil && m.Ban != nil {
		return *m.Ban
	}
	return false
}

// Sent by the server when it communicates new and changed users to client.
// First seen during login procedure. May be sent by the client when it wishes
// to alter its state.
type UserState struct {
	// Unique user session ID of the user whose state this is, may change on
	// reconnect.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The session of the user who is updating this user.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// User name, UTF-8 encoded.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Registered user ID if the user is registered.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id" json:"user_id,omitempty"`
	// Channel on which the user is.
	ChannelId *uint32 `protobuf:"varint,5,opt,name=channel_id" json:"channel_id,omitempty"`
	// True if the user is muted by admin.
	Mute *bool `protobuf:"varint,6,opt,name=mute" json:"mute,omitempty"`
	// True if the user is deafened by admin.
	Deaf *bool `protobuf:"varint,7,opt,name=deaf" json:"deaf,omitempty"`
	// True if the user has been suppressed from talking by a reason other than
	// being muted.
	Suppress *bool `protobuf:"varint,8,opt,name=suppress" json:"suppress,omitempty"`
	// True if the user has muted self.
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute" json:"self_mute,omitempty"`
	// True if the user has deafened self.
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf" json:"self_deaf,omitempty"`
	// User image if it is less than 128 bytes.
	Texture []byte `protobuf:"bytes,11,opt,name=texture" json:"texture,omitempty"`
	// TODO ??
	PluginContext []byte `protobuf:"bytes,12,opt,name=plugin_context" json:"plugin_context,omitempty"`
	// TODO ??
	PluginIdentity *string `protobuf:"bytes,13,opt,name=plugin_identity" json:"plugin_identity,omitempty"`
	// User comment if it is less than 128 bytes.
	Comment *string `protobuf:"bytes,14,opt,name=comment" json:"comment,omitempty"`
	// The hash of the user certificate.
	Hash *string `protobuf:"bytes,15,opt,name=hash" json:"hash,omitempty"`
	// SHA1 hash of the user comment if it 128 bytes or more.
	CommentHash []byte `protobuf:"bytes,16,opt,name=comment_hash" json:"comment_hash,omitempty"`
	// SHA1 hash of the user picture if it 128 bytes or more.
	TextureHash []byte `protobuf:"bytes,17,opt,name=texture_hash" json:"texture_hash,omitempty"`
	// True if the user is a priority speaker.
	PrioritySpeaker *bool `protobuf:"varint,18,opt,name=priority_speaker" json:"priority_speaker,omitempty"`
	// True if the user is currently recording.
	Recording        *bool  `protobuf:"varint,19,opt,name=recording" json:"recording,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UserState) Reset()         { *m = UserState{} }
func (m *UserState) String() string { return proto.CompactTextString(m) }
func (*UserState) ProtoMessage()    {}

func (m *UserState) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserState) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *UserState) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *UserState) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *UserState) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *UserState) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *UserState) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *UserState) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *UserState) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *UserState) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *UserState) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *UserState) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *UserState) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *UserState) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *UserState) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *UserState) GetCommentHash() []byte {
	if m != nil {
		return m.CommentHash
	}
	return nil
}

func (m *UserState) GetTextureHash() []byte {
	if m != nil {
		return m.TextureHash
	}
	return nil
}

func (m *UserState) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *UserState) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

// Relays information on the bans. The client may send the BanList message to
// either modify the list of bans or query them from the server. The server
// sends this list only after a client queries for it.
type BanList struct {
	// List of ban entries currently in place.
	Bans []*BanList_BanEntry `protobuf:"bytes,1,rep,name=bans" json:"bans,omitempty"`
	// True if the server should return the list, false if it should replace old
	// ban list with the one provided.
	Query            *bool  `protobuf:"varint,2,opt,name=query,def=0" json:"query,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BanList) Reset()         { *m = BanList{} }
func (m *BanList) String() string { return proto.CompactTextString(m) }
func (*BanList) ProtoMessage()    {}

const Default_BanList_Query bool = false

func (m *BanList) GetBans() []*BanList_BanEntry {
	if m != nil {
		return m.Bans
	}
	return nil
}

func (m *BanList) GetQuery() bool {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return Default_BanList_Query
}

type BanList_BanEntry struct {
	// Banned IP address.
	Address []byte `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	// The length of the subnet mask for the ban.
	Mask *uint32 `protobuf:"varint,2,req,name=mask" json:"mask,omitempty"`
	// User name for identification purposes (does not affect the ban).
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// TODO ??
	Hash *string `protobuf:"bytes,4,opt,name=hash" json:"hash,omitempty"`
	// Reason for the ban (does not affect the ban).
	Reason *string `protobuf:"bytes,5,opt,name=reason" json:"reason,omitempty"`
	// Ban start time.
	Start *string `protobuf:"bytes,6,opt,name=start" json:"start,omitempty"`
	// Ban duration in seconds.
	Duration         *uint32 `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BanList_BanEntry) Reset()         { *m = BanList_BanEntry{} }
func (m *BanList_BanEntry) String() string { return proto.CompactTextString(m) }
func (*BanList_BanEntry) ProtoMessage()    {}

func (m *BanList_BanEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BanList_BanEntry) GetMask() uint32 {
	if m != nil && m.Mask != nil {
		return *m.Mask
	}
	return 0
}

func (m *BanList_BanEntry) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BanList_BanEntry) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *BanList_BanEntry) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *BanList_BanEntry) GetStart() string {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return ""
}

func (m *BanList_BanEntry) GetDuration() uint32 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

// Used to send and broadcast text messages.
type TextMessage struct {
	// The message sender, identified by its session.
	Actor *uint32 `protobuf:"varint,1,opt,name=actor" json:"actor,omitempty"`
	// Target users for the message, identified by their session.
	Session []uint32 `protobuf:"varint,2,rep,name=session" json:"session,omitempty"`
	// The channels to which the message is sent, identified by their
	// channel_ids.
	ChannelId []uint32 `protobuf:"varint,3,rep,name=channel_id" json:"channel_id,omitempty"`
	// The root channels when sending message recursively to several channels,
	// identified by their channel_ids.
	TreeId []uint32 `protobuf:"varint,4,rep,name=tree_id" json:"tree_id,omitempty"`
	// The UTF-8 encoded message. May be HTML if the server allows.
	Message          *string `protobuf:"bytes,5,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}

func (m *TextMessage) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *TextMessage) GetSession() []uint32 {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *TextMessage) GetChannelId() []uint32 {
	if m != nil {
		return m.ChannelId
	}
	return nil
}

func (m *TextMessage) GetTreeId() []uint32 {
	if m != nil {
		return m.TreeId
	}
	return nil
}

func (m *TextMessage) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

type PermissionDenied struct {
	// The denied permission when type is Permission.
	Permission *uint32 `protobuf:"varint,1,opt,name=permission" json:"permission,omitempty"`
	// channel_id for the channel where the permission was denied when type is
	// Permission.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id" json:"channel_id,omitempty"`
	// The user who was denied permissions, identified by session.
	Session *uint32 `protobuf:"varint,3,opt,name=session" json:"session,omitempty"`
	// Textual reason for the denial.
	Reason *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	// Type of the denial.
	Type *PermissionDenied_DenyType `protobuf:"varint,5,opt,name=type,enum=MumbleProto.PermissionDenied_DenyType" json:"type,omitempty"`
	// The name that is invalid when type is UserName.
	Name             *string `protobuf:"bytes,6,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PermissionDenied) Reset()         { *m = PermissionDenied{} }
func (m *PermissionDenied) String() string { return proto.CompactTextString(m) }
func (*PermissionDenied) ProtoMessage()    {}

func (m *PermissionDenied) GetPermission() uint32 {
	if m != nil && m.Permission != nil {
		return *m.Permission
	}
	return 0
}

func (m *PermissionDenied) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *PermissionDenied) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *PermissionDenied) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *PermissionDenied) GetType() PermissionDenied_DenyType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PermissionDenied_Text
}

func (m *PermissionDenied) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type ACL struct {
	// Channel ID of the channel this message affects.
	ChannelId *uint32 `protobuf:"varint,1,req,name=channel_id" json:"channel_id,omitempty"`
	// True if the channel inherits its parent's ACLs.
	InheritAcls *bool `protobuf:"varint,2,opt,name=inherit_acls,def=1" json:"inherit_acls,omitempty"`
	// User group specifications.
	Groups []*ACL_ChanGroup `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	// ACL specifications.
	Acls []*ACL_ChanACL `protobuf:"bytes,4,rep,name=acls" json:"acls,omitempty"`
	// True if the message is a query for ACLs instead of setting them.
	Query            *bool  `protobuf:"varint,5,opt,name=query,def=0" json:"query,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}

const Default_ACL_InheritAcls bool = true
const Default_ACL_Query bool = false

func (m *ACL) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ACL) GetInheritAcls() bool {
	if m != nil && m.InheritAcls != nil {
		return *m.InheritAcls
	}
	return Default_ACL_InheritAcls
}

func (m *ACL) GetGroups() []*ACL_ChanGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL) GetAcls() []*ACL_ChanACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL) GetQuery() bool {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return Default_ACL_Query
}

type ACL_ChanGroup struct {
	// Name of the channel group, UTF-8 encoded.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// True if the group has been inherited from the parent (Read only).
	Inherited *bool `protobuf:"varint,2,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// True if the group members are inherited.
	Inherit *bool `protobuf:"varint,3,opt,name=inherit,def=1" json:"inherit,omitempty"`
	// True if the group can be inherited by sub channels.
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable,def=1" json:"inheritable,omitempty"`
	// Users explicitly included in this group, identified by user_id.
	Add []uint32 `protobuf:"varint,5,rep,name=add" json:"add,omitempty"`
	// Users explicitly removed from this group in this channel if the group
	// has been inherited, identified by user_id.
	Remove []uint32 `protobuf:"varint,6,rep,name=remove" json:"remove,omitempty"`
	// Users inherited, identified by user_id.
	InheritedMembers []uint32 `protobuf:"varint,7,rep,name=inherited_members" json:"inherited_members,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_ChanGroup) Reset()         { *m = ACL_ChanGroup{} }
func (m *ACL_ChanGroup) String() string { return proto.CompactTextString(m) }
func (*ACL_ChanGroup) ProtoMessage()    {}

const Default_ACL_ChanGroup_Inherited bool = true
const Default_ACL_ChanGroup_Inherit bool = true
const Default_ACL_ChanGroup_Inheritable bool = true

func (m *ACL_ChanGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_ChanGroup) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return Default_ACL_ChanGroup_Inherited
}

func (m *ACL_ChanGroup) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return Default_ACL_ChanGroup_Inherit
}

func (m *ACL_ChanGroup) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return Default_ACL_ChanGroup_Inheritable
}

func (m *ACL_ChanGroup) GetAdd() []uint32 {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *ACL_ChanGroup) GetRemove() []uint32 {
	if m != nil {
		return m.Remove
	}
	return nil
}

func (m *ACL_ChanGroup) GetInheritedMembers() []uint32 {
	if m != nil {
		return m.InheritedMembers
	}
	return nil
}

type ACL_ChanACL struct {
	// True if this ACL applies to the current channel.
	ApplyHere *bool `protobuf:"varint,1,opt,name=apply_here,def=1" json:"apply_here,omitempty"`
	// True if this ACL applies to the sub channels.
	ApplySubs *bool `protobuf:"varint,2,opt,name=apply_subs,def=1" json:"apply_subs,omitempty"`
	// True if the ACL has been inherited from the parent.
	Inherited *bool `protobuf:"varint,3,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// ID of the user that is affected by this ACL.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id" json:"user_id,omitempty"`
	// ID of the group that is affected by this ACL.
	Group *string `protobuf:"bytes,5,opt,name=group" json:"group,omitempty"`
	// Bit flag field of the permissions granted by this ACL.
	Grant *uint32 `protobuf:"varint,6,opt,name=grant" json:"grant,omitempty"`
	// Bit flag field of the permissions denied by this ACL.
	Deny             *uint32 `protobuf:"varint,7,opt,name=deny" json:"deny,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL_ChanACL) Reset()         { *m = ACL_ChanACL{} }
func (m *ACL_ChanACL) String() string { return proto.CompactTextString(m) }
func (*ACL_ChanACL) ProtoMessage()    {}

const Default_ACL_ChanACL_ApplyHere bool = true
const Default_ACL_ChanACL_ApplySubs bool = true
const Default_ACL_ChanACL_Inherited bool = true

func (m *ACL_ChanACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return Default_ACL_ChanACL_ApplyHere
}

func (m *ACL_ChanACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return Default_ACL_ChanACL_ApplySubs
}

func (m *ACL_ChanACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return Default_ACL_ChanACL_Inherited
}

func (m *ACL_ChanACL) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *ACL_ChanACL) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *ACL_ChanACL) GetGrant() uint32 {
	if m != nil && m.Grant != nil {
		return *m.Grant
	}
	return 0
}

func (m *ACL_ChanACL) GetDeny() uint32 {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return 0
}

// Client may use this message to refresh its registered user information. The
// client should fill the IDs or Names of the users it wants to refresh. The
// server fills the missing parts and sends the message back.
type QueryUsers struct {
	// user_ids.
	Ids []uint32 `protobuf:"varint,1,rep,name=ids" json:"ids,omitempty"`
	// User names in the same order as ids.
	Names            []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *QueryUsers) Reset()         { *m = QueryUsers{} }
func (m *QueryUsers) String() string { return proto.CompactTextString(m) }
func (*QueryUsers) ProtoMessage()    {}

func (m *QueryUsers) GetIds() []uint32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *QueryUsers) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Used to initialize and resync the UDP encryption. Either side may request a
// resync by sending the message without any values filled. The resync is
// performed by sending the message with only the client or server nonce
// filled.
type CryptSetup struct {
	// Encryption key.
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Client nonce.
	ClientNonce []byte `protobuf:"bytes,2,opt,name=client_nonce" json:"client_nonce,omitempty"`
	// Server nonce.
	ServerNonce      []byte `protobuf:"bytes,3,opt,name=server_nonce" json:"server_nonce,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CryptSetup) Reset()         { *m = CryptSetup{} }
func (m *CryptSetup) String() string { return proto.CompactTextString(m) }
func (*CryptSetup) ProtoMessage()    {}

func (m *CryptSetup) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *CryptSetup) GetClientNonce() []byte {
	if m != nil {
		return m.ClientNonce
	}
	return nil
}

func (m *CryptSetup) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

type ContextActionModify struct {
	// The action name.
	Action *string `protobuf:"bytes,1,req,name=action" json:"action,omitempty"`
	// The display name of the action.
	Text *string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// Context bit flags defining where the action should be displayed.
	Context          *uint32                        `protobuf:"varint,3,opt,name=context" json:"context,omitempty"`
	Operation        *ContextActionModify_Operation `protobuf:"varint,4,opt,name=operation,enum=MumbleProto.ContextActionModify_Operation" json:"operation,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *ContextActionModify) Reset()         { *m = ContextActionModify{} }
func (m *ContextActionModify) String() string { return proto.CompactTextString(m) }
func (*ContextActionModify) ProtoMessage()    {}

func (m *ContextActionModify) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextActionModify) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextActionModify) GetContext() uint32 {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return 0
}

func (m *ContextActionModify) GetOperation() ContextActionModify_Operation {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return ContextActionModify_Add
}

// Sent by the client when it wants to initiate a Context action.
type ContextAction struct {
	// The target User for the action, identified by session.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The target Channel for the action, identified by channel_id.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id" json:"channel_id,omitempty"`
	// The action that should be executed.
	Action           *string `protobuf:"bytes,3,req,name=action" json:"action,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContextAction) Reset()         { *m = ContextAction{} }
func (m *ContextAction) String() string { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()    {}

func (m *ContextAction) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *ContextAction) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

// Lists the registered users.
type UserList struct {
	// A list of registered users.
	Users            []*UserList_User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *UserList) Reset()         { *m = UserList{} }
func (m *UserList) String() string { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()    {}

func (m *UserList) GetUsers() []*UserList_User {
	if m != nil {
		return m.Users
	}
	return nil
}

type UserList_User struct {
	// Registered user ID.
	UserId *uint32 `protobuf:"varint,1,req,name=user_id" json:"user_id,omitempty"`
	// Registered user name.
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	LastSeen         *string `protobuf:"bytes,3,opt,name=last_seen" json:"last_seen,omitempty"`
	LastChannel      *uint32 `protobuf:"varint,4,opt,name=last_channel" json:"last_channel,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserList_User) Reset()         { *m = UserList_User{} }
func (m *UserList_User) String() string { return proto.CompactTextString(m) }
func (*UserList_User) ProtoMessage()    {}

func (m *UserList_User) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *UserList_User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *UserList_User) GetLastSeen() string {
	if m != nil && m.LastSeen != nil {
		return *m.LastSeen
	}
	return ""
}

func (m *UserList_User) GetLastChannel() uint32 {
	if m != nil && m.LastChannel != nil {
		return *m.LastChannel
	}
	return 0
}

// Sent by the client when it wants to register or clear whisper targets.
//
// Note: The first available target ID is 1 as 0 is reserved for normal
// talking. Maximum target ID is 30.
type VoiceTarget struct {
	// Voice target ID.
	Id *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The receivers that this voice target includes.
	Targets          []*VoiceTarget_Target `protobuf:"bytes,2,rep,name=targets" json:"targets,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *VoiceTarget) Reset()         { *m = VoiceTarget{} }
func (m *VoiceTarget) String() string { return proto.CompactTextString(m) }
func (*VoiceTarget) ProtoMessage()    {}

func (m *VoiceTarget) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *VoiceTarget) GetTargets() []*VoiceTarget_Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

type VoiceTarget_Target struct {
	// Users that are included as targets.
	Session []uint32 `protobuf:"varint,1,rep,name=session" json:"session,omitempty"`
	// Channels that are included as targets.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id" json:"channel_id,omitempty"`
	// TODO ??
	Group *string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	// True if the voice should follow links from the specified channel.
	Links *bool `protobuf:"varint,4,opt,name=links,def=0" json:"links,omitempty"`
	// True if the voice should also be sent to children of the specific
	// channel.
	Children         *bool  `protobuf:"varint,5,opt,name=children,def=0" json:"children,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VoiceTarget_Target) Reset()         { *m = VoiceTarget_Target{} }
func (m *VoiceTarget_Target) String() string { return proto.CompactTextString(m) }
func (*VoiceTarget_Target) ProtoMessage()    {}

const Default_VoiceTarget_Target_Links bool = false
const Default_VoiceTarget_Target_Children bool = false

func (m *VoiceTarget_Target) GetSession() []uint32 {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *VoiceTarget_Target) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *VoiceTarget_Target) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *VoiceTarget_Target) GetLinks() bool {
	if m != nil && m.Links != nil {
		return *m.Links
	}
	return Default_VoiceTarget_Target_Links
}

func (m *VoiceTarget_Target) GetChildren() bool {
	if m != nil && m.Children != nil {
		return *m.Children
	}
	return Default_VoiceTarget_Target_Children
}

// Sent by the client when it wants permissions for a certain channel. Sent by
// the server when it replies to the query or wants the user to resync all
// channel permissions.
type PermissionQuery struct {
	// channel_id of the channel for which the permissions are queried.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id" json:"channel_id,omitempty"`
	// Channel permissions.
	Permissions *uint32 `protobuf:"varint,2,opt,name=permissions" json:"permissions,omitempty"`
	// True if the client should drop its current permission information for all
	// channels.
	Flush            *bool  `protobuf:"varint,3,opt,name=flush,def=0" json:"flush,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PermissionQuery) Reset()         { *m = PermissionQuery{} }
func (m *PermissionQuery) String() string { return proto.CompactTextString(m) }
func (*PermissionQuery) ProtoMessage()    {}

const Default_PermissionQuery_Flush bool = false

func (m *PermissionQuery) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *PermissionQuery) GetPermissions() uint32 {
	if m != nil && m.Permissions != nil {
		return *m.Permissions
	}
	return 0
}

func (m *PermissionQuery) GetFlush() bool {
	if m != nil && m.Flush != nil {
		return *m.Flush
	}
	return Default_PermissionQuery_Flush
}

// Sent by the server to notify the users of the version of the CELT codec they
// should use. This may change during the connection when new users join.
type CodecVersion struct {
	// The version of the CELT Alpha codec.
	Alpha *int32 `protobuf:"varint,1,req,name=alpha" json:"alpha,omitempty"`
	// The version of the CELT Beta codec.
	Beta *int32 `protobuf:"varint,2,req,name=beta" json:"beta,omitempty"`
	// True if the user should prefer Alpha over Beta.
	PreferAlpha      *bool  `protobuf:"varint,3,req,name=prefer_alpha,def=1" json:"prefer_alpha,omitempty"`
	Opus             *bool  `protobuf:"varint,4,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CodecVersion) Reset()         { *m = CodecVersion{} }
func (m *CodecVersion) String() string { return proto.CompactTextString(m) }
func (*CodecVersion) ProtoMessage()    {}

const Default_CodecVersion_PreferAlpha bool = true
const Default_CodecVersion_Opus bool = false

func (m *CodecVersion) GetAlpha() int32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return 0
}

func (m *CodecVersion) GetBeta() int32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return 0
}

func (m *CodecVersion) GetPreferAlpha() bool {
	if m != nil && m.PreferAlpha != nil {
		return *m.PreferAlpha
	}
	return Default_CodecVersion_PreferAlpha
}

func (m *CodecVersion) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_CodecVersion_Opus
}

// Used to communicate user stats between the server and clients.
type UserStats struct {
	// User whose stats these are.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// True if the message contains only mutable stats (packets, ping).
	StatsOnly *bool `protobuf:"varint,2,opt,name=stats_only,def=0" json:"stats_only,omitempty"`
	// Full user certificate chain of the user certificate in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// Packet statistics for packets received from the client.
	FromClient *UserStats_Stats `protobuf:"bytes,4,opt,name=from_client" json:"from_client,omitempty"`
	// Packet statistics for packets sent by the server.
	FromServer *UserStats_Stats `protobuf:"bytes,5,opt,name=from_server" json:"from_server,omitempty"`
	// Amount of UDP packets sent.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets" json:"udp_packets,omitempty"`
	// Amount of TCP packets sent.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var" json:"tcp_ping_var,omitempty"`
	// Client version.
	Version *Version `protobuf:"bytes,12,opt,name=version" json:"version,omitempty"`
	// A list of CELT bitstream version constants supported by the client of this
	// user.
	CeltVersions []int32 `protobuf:"varint,13,rep,name=celt_versions" json:"celt_versions,omitempty"`
	// Client IP address.
	Address []byte `protobuf:"bytes,14,opt,name=address" json:"address,omitempty"`
	// Bandwith used by this client.
	Bandwidth *uint32 `protobuf:"varint,15,opt,name=bandwidth" json:"bandwidth,omitempty"`
	// Connection duration.
	Onlinesecs *uint32 `protobuf:"varint,16,opt,name=onlinesecs" json:"onlinesecs,omitempty"`
	// Duration since last activity.
	Idlesecs *uint32 `protobuf:"varint,17,opt,name=idlesecs" json:"idlesecs,omitempty"`
	// True if the user has a strong certificate.
	StrongCertificate *bool  `protobuf:"varint,18,opt,name=strong_certificate,def=0" json:"strong_certificate,omitempty"`
	Opus              *bool  `protobuf:"varint,19,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *UserStats) Reset()         { *m = UserStats{} }
func (m *UserStats) String() string { return proto.CompactTextString(m) }
func (*UserStats) ProtoMessage()    {}

const Default_UserStats_StatsOnly bool = false
const Default_UserStats_StrongCertificate bool = false
const Default_UserStats_Opus bool = false

func (m *UserStats) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserStats) GetStatsOnly() bool {
	if m != nil && m.StatsOnly != nil {
		return *m.StatsOnly
	}
	return Default_UserStats_StatsOnly
}

func (m *UserStats) GetCertificates() [][]byte {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *UserStats) GetFromClient() *UserStats_Stats {
	if m != nil {
		return m.FromClient
	}
	return nil
}

func (m *UserStats) GetFromServer() *UserStats_Stats {
	if m != nil {
		return m.FromServer
	}
	return nil
}

func (m *UserStats) GetUdpPackets() uint32 {
	if m != nil && m.UdpPackets != nil {
		return *m.UdpPackets
	}
	return 0
}

func (m *UserStats) GetTcpPackets() uint32 {
	if m != nil && m.TcpPackets != nil {
		return *m.TcpPackets
	}
	return 0
}

func (m *UserStats) GetUdpPingAvg() float32 {
	if m != nil && m.UdpPingAvg != nil {
		return *m.UdpPingAvg
	}
	return 0
}

func (m *UserStats) GetUdpPingVar() float32 {
	if m != nil && m.UdpPingVar != nil {
		return *m.UdpPingVar
	}
	return 0
}

func (m *UserStats) GetTcpPingAvg() float32 {
	if m != nil && m.TcpPingAvg != nil {
		return *m.TcpPingAvg
	}
	return 0
}

func (m *UserStats) GetTcpPingVar() float32 {
	if m != nil && m.TcpPingVar != nil {
		return *m.TcpPingVar
	}
	return 0
}

func (m *UserStats) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *UserStats) GetCeltVersions() []int32 {
	if m != nil {
		return m.CeltVersions
	}
	return nil
}

func (m *UserStats) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UserStats) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

func (m *UserStats) GetOnlinesecs() uint32 {
	if m != nil && m.Onlinesecs != nil {
		return *m.Onlinesecs
	}
	return 0
}

func (m *UserStats) GetIdlesecs() uint32 {
	if m != nil && m.Idlesecs != nil {
		return *m.Idlesecs
	}
	return 0
}

func (m *UserStats) GetStrongCertificate() bool {
	if m != nil && m.StrongCertificate != nil {
		return *m.StrongCertificate
	}
	return Default_UserStats_StrongCertificate
}

func (m *UserStats) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_UserStats_Opus
}

type UserStats_Stats struct {
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,1,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,2,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,3,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync           *uint32 `protobuf:"varint,4,opt,name=resync" json:"resync,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserStats_Stats) Reset()         { *m = UserStats_Stats{} }
func (m *UserStats_Stats) String() string { return proto.CompactTextString(m) }
func (*UserStats_Stats) ProtoMessage()    {}

func (m *UserStats_Stats) GetGood() uint32 {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return 0
}

func (m *UserStats_Stats) GetLate() uint32 {
	if m != nil && m.Late != nil {
		return *m.Late
	}
	return 0
}

func (m *UserStats_Stats) GetLost() uint32 {
	if m != nil && m.Lost != nil {
		return *m.Lost
	}
	return 0
}

func (m *UserStats_Stats) GetResync() uint32 {
	if m != nil && m.Resync != nil {
		return *m.Resync
	}
	return 0
}

// Used by the client to request binary data from the server. By default large
// comments or textures are not sent within standard messages but instead the
// hash is. If the client does not recognize the hash it may request the
// resource when it needs it. The client does so by sending a RequestBlob
// message with the correct fields filled with the user sessions or channel_ids
// it wants to receive. The server replies to this by sending a new
// UserState/ChannelState message with the resources filled even if they would
// normally be transmitted as hashes.
type RequestBlob struct {
	// sessions of the requested UserState textures.
	SessionTexture []uint32 `protobuf:"varint,1,rep,name=session_texture" json:"session_texture,omitempty"`
	// sessions of the requested UserState comments.
	SessionComment []uint32 `protobuf:"varint,2,rep,name=session_comment" json:"session_comment,omitempty"`
	// channel_ids of the requested ChannelState descriptions.
	ChannelDescription []uint32 `protobuf:"varint,3,rep,name=channel_description" json:"channel_description,omitempty"`
	XXX_unrecognized   []byte   `json:"-"`
}

func (m *RequestBlob) Reset()         { *m = RequestBlob{} }
func (m *RequestBlob) String() string { return proto.CompactTextString(m) }
func (*RequestBlob) ProtoMessage()    {}

func (m *RequestBlob) GetSessionTexture() []uint32 {
	if m != nil {
		return m.SessionTexture
	}
	return nil
}

func (m *RequestBlob) GetSessionComment() []uint32 {
	if m != nil {
		return m.SessionComment
	}
	return nil
}

func (m *RequestBlob) GetChannelDescription() []uint32 {
	if m != nil {
		return m.ChannelDescription
	}
	return nil
}

// Sent by the server when it informs the clients on server configuration
// details.
type ServerConfig struct {
	// The maximum bandwidth the clients should use.
	MaxBandwidth *uint32 `protobuf:"varint,1,opt,name=max_bandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,2,opt,name=welcome_text" json:"welcome_text,omitempty"`
	// True if the server allows HTML.
	AllowHtml *bool `protobuf:"varint,3,opt,name=allow_html" json:"allow_html,omitempty"`
	// Maximum text message length.
	MessageLength *uint32 `protobuf:"varint,4,opt,name=message_length" json:"message_length,omitempty"`
	// Maximum image message length.
	ImageMessageLength *uint32 `protobuf:"varint,5,opt,name=image_message_length" json:"image_message_length,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *ServerConfig) Reset()         { *m = ServerConfig{} }
func (m *ServerConfig) String() string { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()    {}

func (m *ServerConfig) GetMaxBandwidth() uint32 {
	if m != nil && m.MaxBandwidth != nil {
		return *m.MaxBandwidth
	}
	return 0
}

func (m *ServerConfig) GetWelcomeText() string {
	if m != nil && m.WelcomeText != nil {
		return *m.WelcomeText
	}
	return ""
}

func (m *ServerConfig) GetAllowHtml() bool {
	if m != nil && m.AllowHtml != nil {
		return *m.AllowHtml
	}
	return false
}

func (m *ServerConfig) GetMessageLength() uint32 {
	if m != nil && m.MessageLength != nil {
		return *m.MessageLength
	}
	return 0
}

func (m *ServerConfig) GetImageMessageLength() uint32 {
	if m != nil && m.ImageMessageLength != nil {
		return *m.ImageMessageLength
	}
	return 0
}

// Sent by the server to inform the clients of suggested client configuration
// specified by the server administrator.
type SuggestConfig struct {
	// Suggested client version.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// True if the administrator suggests positional audio to be used on this
	// server.
	Positional *bool `protobuf:"varint,2,opt,name=positional" json:"positional,omitempty"`
	// True if the administrator suggests push to talk to be used on this server.
	PushToTalk       *bool  `protobuf:"varint,3,opt,name=push_to_talk" json:"push_to_talk,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SuggestConfig) Reset()         { *m = SuggestConfig{} }
func (m *SuggestConfig) String() string { return proto.CompactTextString(m) }
func (*SuggestConfig) ProtoMessage()    {}

func (m *SuggestConfig) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *SuggestConfig) GetPositional() bool {
	if m != nil && m.Positional != nil {
		return *m.Positional
	}
	return false
}

func (m *SuggestConfig) GetPushToTalk() bool {
	if m != nil && m.PushToTalk != nil {
		return *m.PushToTalk
	}
	return false
}

func init() {
	proto.RegisterEnum("MumbleProto.Reject_RejectType", Reject_RejectType_name, Reject_RejectType_value)
	proto.RegisterEnum("MumbleProto.PermissionDenied_DenyType", PermissionDenied_DenyType_name, PermissionDenied_DenyType_value)
	proto.RegisterEnum("MumbleProto.ContextActionModify_Context", ContextActionModify_Context_name, ContextActionModify_Context_value)
	proto.RegisterEnum("MumbleProto.ContextActionModify_Operation", ContextActionModify_Operation_name, ContextActionModify_Operation_value)
}
